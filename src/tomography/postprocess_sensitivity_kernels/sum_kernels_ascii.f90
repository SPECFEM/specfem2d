!========================================================================
!
!                   S P E C F E M 2 D  Version 7 . 0
!                   --------------------------------
!
!     Main historical authors: Dimitri Komatitsch and Jeroen Tromp
!                              CNRS, France
!                       and Princeton University, USA
!                 (there are currently many more authors!)
!                           (c) October 2017
!
! This software is a computer program whose purpose is to solve
! the two-dimensional viscoelastic anisotropic or poroelastic wave equation
! using a spectral-element method (SEM).
!
! This program is free software; you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation; either version 3 of the License, or
! (at your option) any later version.
!
! This program is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License along
! with this program; if not, write to the Free Software Foundation, Inc.,
! 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
!
! The full text of the license is available in file "LICENSE".
!
!========================================================================

! XSUM_KERNELS_ASCII
!
! USAGE
!   NPROC bin/xsum_kernels_ascii INPUT_FILE OUTPUT_DIR
!
!
! COMMAND LINE ARGUMENTS
!   INPUT_FILE             - text file containing list of kernel directories
!   OUTPUT_PATH            - directory to which summed kernels are written
!
!
! DESCRIPTION
!   Sums kernels from directories specified in INPUT_FILE.
!   Writes the resulting sums to OUTPUT_DIR.
!
!   INPUT_FILE is a text file containing a list of absolute or relative paths to
!   kernel directories, one directory per line. Each kernel directory must
!   contain the following ASCII files, which are generated by SPECFEM2D when
!   adjoint simulation and ascii kernel options are specified:
!
!     proc000000_rhop_alpha_beta_kernel.dat
!     proc000000_rho_kappa_mu.dat
!
!   This routine is modeled after xsum_kernels in SPECFEM3D, in so far as
!   similarities between 2D and 3D packages allow.


program sum_kernels_ascii

  use postprocess_par, only: MAX_STRING_LEN, MAX_KERNEL_PATHS, MAX_KERNEL_NAMES, &
    IIN

  implicit none

  integer, parameter :: NARGS = 2

  integer :: ipath, npath, iker, nlines, i,j
  double precision, allocatable, dimension(:) :: kernel1, kernel2, kernel3
  double precision, allocatable, dimension(:) :: kernel_sum1, kernel_sum2, kernel_sum3
  double precision, allocatable, dimension(:,:) :: coord
  character(len=MAX_STRING_LEN) :: input_file, output_dir, kernel_name
  character(len=MAX_STRING_LEN) :: kernel_paths(MAX_KERNEL_PATHS)
  character(len=MAX_STRING_LEN) :: filename, arg(2), line
  integer :: ier
  double precision :: dummy1, dummy2


  write(*,*) 'Running XSUM_KERNELS_ASCII'
  write(*,*)

  if (command_argument_count() /= NARGS) then
    print *, 'USAGE: bin/xsum_kernels_ascii INPUT_FILE OUTPUT_DIR'
    print *
    call stop_the_code('Please check command line arguments')
  endif

  ! parse command line arguments
  do i = 1, NARGS
    call get_command_argument(i,arg(i), status=ier)
  enddo

  read(arg(1),'(a)') input_file
  read(arg(2),'(a)') output_dir

  ! parse paths from INPUT_FILE
  npath=0
  open(unit = IIN, file = trim(input_file), status = 'old',iostat = ier)
  if (ier /= 0) then
     print *,'Error opening ',trim(input_file)
     call stop_the_code('Please check command line argument: INPUT_FILE')
  endif
  do while (1 == 1)
     read(IIN,'(a)',iostat=ier) line
     if (ier /= 0) exit
     npath = npath+1
     if (npath > MAX_KERNEL_PATHS) call stop_the_code('Error number of paths exceeds MAX_KERNEL_PATHS')
     kernel_paths(npath) = line
  enddo
  close(IIN)

  ! print status update
  write(*,*) 'Running XSUM_KERNELS_ASCII'
  write(*,*)

  write(*,*) 'Combining arrays from ',npath,' paths'
  write(*,*)

  ! allocate arrays
  call get_number_gll_points((kernel_paths(1)), nlines)
  allocate( coord(2,nlines) )
  allocate( kernel1(nlines) )
  allocate( kernel2(nlines) )
  allocate( kernel3(nlines) )
  allocate( kernel_sum1(nlines) )
  allocate( kernel_sum2(nlines) )
  allocate( kernel_sum3(nlines) )
  kernel1(:) = 0.0d0
  kernel2(:) = 0.0d0
  kernel3(:) = 0.0d0
  kernel_sum1(:) = 0.0d0
  kernel_sum2(:) = 0.0d0
  kernel_sum3(:) = 0.0d0

  ! sum kernels
  do iker = 1, 2

    if (iker == 1) write(kernel_name,'(a)') 'proc000000_rhop_alpha_beta_kernel.dat'
    if (iker == 2) write(kernel_name,'(a)') 'proc000000_rho_kappa_mu_kernel.dat'

    ! sum kernels
    do ipath = 1, npath
       filename = trim(kernel_paths(ipath)) //'/'// trim(kernel_name)
       open(unit=3,file=filename, status='old', action='read')
       do j = 1,nlines
          read(3,*) dummy1, dummy2, kernel1(j), kernel2(j), kernel3(j)
       enddo
       close(3)

       if (ipath == 1) then
          kernel_sum1 = kernel1
          kernel_sum2 = kernel2
          kernel_sum3 = kernel3
       else
         kernel_sum1(:)=kernel_sum1(:)+kernel1(:)
         kernel_sum2(:)=kernel_sum2(:)+kernel2(:)
         kernel_sum3(:)=kernel_sum3(:)+kernel3(:)
       endif
    enddo

    ! save result
    filename = trim(output_dir) //'/'// trim(kernel_name)
    open(unit=4,file=filename,status='unknown',action='write')
    do j = 1, nlines
          write(4,'(5e11.3)') coord(1,j),coord(2,j),kernel_sum1(j),kernel_sum2(j),kernel_sum3(j)
    enddo
    close(4)

  enddo

  write(*,*) 'Finished writing kernels '
  write(*,*)

end program sum_kernels_ascii


! ------------------------------------------------------------------------------

  subroutine get_number_gll_points(kernel_path, nlines)

  use postprocess_par, only: MAX_STRING_LEN, MAX_LINES

  implicit none

  double precision :: dummy1, dummy2, dummy3, dummy4, dummy5

  character(len=MAX_STRING_LEN) :: kernel_path, filename

  integer :: j, ios, nlines

  filename = trim(kernel_path)//'/'//'proc000000_rhop_alpha_beta_kernel.dat'
  open(unit=3,file=filename,status='old',action='read')
  nlines = 0
  do j = 1,MAX_LINES
     read(3,*,iostat=ios) dummy1, dummy2, dummy3, dummy4, dummy5
     if (ios /= 0) exit
     nlines=nlines+1
  enddo
  close(3)

  end subroutine get_number_gll_points

