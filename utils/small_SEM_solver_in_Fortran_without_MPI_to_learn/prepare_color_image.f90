!========================================================================
!
!                   S P E C F E M 2 D  Version 7 . 0
!                   --------------------------------
!
!     Main historical authors: Dimitri Komatitsch and Jeroen Tromp
!                              CNRS, France
!                       and Princeton University, USA
!                 (there are currently many more authors!)
!                           (c) October 2017
!               Pieyre Le Loher, pieyre DOT le-loher aT inria.fr
!
! This software is a computer program whose purpose is to solve
! the two-dimensional viscoelastic anisotropic or poroelastic wave equation
! using a spectral-element method (SEM).
!
! This program is free software; you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation; either version 3 of the License, or
! (at your option) any later version.
!
! This program is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License along
! with this program; if not, write to the Free Software Foundation, Inc.,
! 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
!
! The full text of the license is available in file "LICENSE".
!
!========================================================================

  subroutine prepare_color_image_init(NDIM,NGLOB,NGLLX,coord,npgeo,NX_IMAGE_color,NZ_IMAGE_color, &
                          xmin_color_image,xmax_color_image,zmin_color_image,zmax_color_image)

  implicit none

  integer  :: npgeo,NDIM,NGLOB,NGLLX,NX_IMAGE_color,NZ_IMAGE_color
  double precision  :: xmin_color_image,xmax_color_image,zmin_color_image,zmax_color_image

! arrays with the mesh in double precision
  double precision, dimension(NDIM,NGLOB) :: coord

! these parameters may be changed one day if needed
  double precision, parameter :: factor_subsample_image = 0.50d0 ! 1.d0
! maximum size of the X and Z directions of a JPEG image generated by the display routine
  integer, parameter :: NX_NZ_IMAGE_MAX = 10000


  ! local parameters
  integer  :: npgeo_glob
  double precision  :: xmin_color_image_loc, xmax_color_image_loc,zmin_color_image_loc,zmax_color_image_loc

  ! horizontal size of the image
  xmin_color_image_loc = minval(coord(1,:))
  xmax_color_image_loc = maxval(coord(1,:))

  ! vertical size of the image, slightly increase it to go beyond maximum topography
  zmin_color_image_loc = minval(coord(2,:))
  zmax_color_image_loc = maxval(coord(2,:))

! global values
  xmin_color_image = xmin_color_image_loc
  xmax_color_image = xmax_color_image_loc
  zmin_color_image = zmin_color_image_loc
  zmax_color_image = zmax_color_image_loc
  npgeo_glob = npgeo

! small area above the max of topography, visually looks better
!!!!!!  zmax_color_image = zmin_color_image + 1.05d0 * (zmax_color_image - zmin_color_image)

  ! compute number of pixels in the horizontal direction based on typical number
  ! of spectral elements in a given direction (may give bad results for very elongated models)
  NX_IMAGE_color = nint(sqrt(dble(npgeo_glob))) * (NGLLX-1) + 1

  ! compute number of pixels in the vertical direction based on ratio of sizes
  NZ_IMAGE_color = nint(NX_IMAGE_color * (zmax_color_image - zmin_color_image) &
                                      / (xmax_color_image - xmin_color_image))

  ! convert pixel sizes to even numbers because easier to reduce size,
  ! create MPEG movies in postprocessing
  NX_IMAGE_color = 2 * nint((NX_IMAGE_color / 2 + 1) / factor_subsample_image)
  NZ_IMAGE_color = 2 * nint((NZ_IMAGE_color / 2 + 1) / factor_subsample_image)

  ! check that image size is not too big
! because from http://www.jpegcameras.com/libjpeg/libjpeg-2.html
! we know that the size limit of the image in each dimension is 65535:
! "JPEG supports image dimensions of 1 to 64K pixels in either direction".
  if (NX_IMAGE_color < 4) stop 'output image too small: NX_IMAGE_color < 4.'
  if (NZ_IMAGE_color < 4) stop 'output image too small: NZ_IMAGE_color < 4.'

  if (NX_IMAGE_color > 65534) &
    stop 'output image too big: NX_IMAGE_color > 65534; increase factor_subsample_image in DATA/Par_file.'
  if (NZ_IMAGE_color > 65534) &
    stop 'output image too big: NZ_IMAGE_color > 65534; increase factor_subsample_image in DATA/Par_file.'

  if (NX_IMAGE_color > NX_NZ_IMAGE_MAX) then
    print *,'NX_IMAGE_color,NX_NZ_IMAGE_MAX = ',NX_IMAGE_color,NX_NZ_IMAGE_MAX
    stop 'output image too big: NX_IMAGE_color > NX_NZ_IMAGE_MAX; increase factor_subsample_image or change NX_NZ_IMAGE_MAX.'
  endif
  if (NZ_IMAGE_color > NX_NZ_IMAGE_MAX) then
    print *,'NZ_IMAGE_color,NX_NZ_IMAGE_MAX = ',NZ_IMAGE_color,NX_NZ_IMAGE_MAX
    stop 'output image too big: NZ_IMAGE_color > NX_NZ_IMAGE_MAX; increase factor_subsample_image or change NX_NZ_IMAGE_MAX.'
  endif

  end subroutine prepare_color_image_init

!
!-------------------------------------------------------------------------------------------------
!

  subroutine prepare_color_image_pixels(ngnod,npgeo,nspec,NDIM,NGLOB,NGLLX,NGLLZ,NX_IMAGE_color,NZ_IMAGE_color,NSOURCES,nrec, &
        xmin_color_image,xmax_color_image,zmin_color_image,zmax_color_image,x_source,z_source,x_receiver,z_receiver, &
        coord,coorg,knods,ibool,iglob_image_color,ix_image_color_source,iy_image_color_source, &
        ix_image_color_receiver,iy_image_color_receiver)

  implicit none

  integer  :: ngnod,npgeo,nspec,NDIM,NGLOB,NGLLX,NGLLZ,NX_IMAGE_color,NZ_IMAGE_color,NSOURCES,nrec
  double precision  :: xmin_color_image,xmax_color_image,zmin_color_image,zmax_color_image

  double precision :: x_source,z_source
  double precision :: x_receiver,z_receiver

! arrays with the mesh in double precision
  double precision, dimension(NDIM,NGLOB) :: coord

! coordinates of all the corners of the mesh elements in another format
  double precision, dimension(NDIM,npgeo) :: coorg

! numbering of the four corners of each mesh element
  integer, dimension(ngnod,NSPEC) :: knods

  integer, dimension(NGLLX,NGLLZ,NSPEC) :: ibool

  integer, dimension(NX_IMAGE_color,NZ_IMAGE_color) :: iglob_image_color

  integer, dimension(NSOURCES) :: ix_image_color_source,iy_image_color_source
  integer, dimension(nrec) :: ix_image_color_receiver,iy_image_color_receiver

  ! local parameters
  double precision  :: size_pixel_horizontal,size_pixel_vertical
  double precision, dimension(2,4)  :: elmnt_coords
  double precision  :: i_coord, j_coord
  double precision  :: dist_pixel, dist_min_pixel
  integer  :: min_i, min_j, max_i, max_j
  integer  :: ispec,i,j,k,l,iglob,pixel_k,pixel_l
  integer  :: nb_pixel_total,nb_pixel_loc
  logical  :: pixel_is_in

  double precision, parameter :: HUGEVAL = 1.d+30

  ! create all the pixels
  write(*,*) '  locating all the pixels of color images'

  size_pixel_horizontal = (xmax_color_image - xmin_color_image) / dble(NX_IMAGE_color-1)
  size_pixel_vertical = (zmax_color_image - zmin_color_image) / dble(NZ_IMAGE_color-1)

  ! initializes
  iglob_image_color(:,:) = -1

  ! checking which pixels are inside each element
  nb_pixel_loc = 0
  do ispec = 1, nspec

    do k = 1, 4
      elmnt_coords(1,k) = coorg(1,knods(k,ispec))
      elmnt_coords(2,k) = coorg(2,knods(k,ispec))
    enddo

    ! avoid working on the whole pixel grid
    min_i = floor(minval((elmnt_coords(1,:) - xmin_color_image))/size_pixel_horizontal) + 1
    max_i = ceiling(maxval((elmnt_coords(1,:) - xmin_color_image))/size_pixel_horizontal) + 1
    min_j = floor(minval((elmnt_coords(2,:) - zmin_color_image))/size_pixel_vertical) + 1
    max_j = ceiling(maxval((elmnt_coords(2,:) - zmin_color_image))/size_pixel_vertical) + 1

    ! avoid edge effects
    if (min_i < 1) min_i = 1
    if (min_j < 1) min_j = 1

    if (max_i > NX_IMAGE_color) max_i = NX_IMAGE_color
    if (max_j > NZ_IMAGE_color) max_j = NZ_IMAGE_color

    do j = min_j, max_j
      do i = min_i, max_i
        i_coord = (i-1)*size_pixel_horizontal + xmin_color_image
        j_coord = (j-1)*size_pixel_vertical + zmin_color_image

        ! checking if the pixel is inside the element (must be a convex quadrilateral)
        call is_in_convex_quadrilateral( elmnt_coords, i_coord, j_coord, pixel_is_in)

        ! if inside, getting the nearest point inside the element!
        if (pixel_is_in) then
          dist_min_pixel = HUGEVAL
          do k = 1, NGLLX
            do l = 1, NGLLZ
              iglob = ibool(k,l,ispec)
              dist_pixel = (coord(1,iglob)-i_coord)**2 + (coord(2,iglob)-j_coord)**2
              if (dist_pixel < dist_min_pixel) then
                dist_min_pixel = dist_pixel
                pixel_l = l
                pixel_k = k
              endif
            enddo
          enddo
          ! checks if pixel found
          if (dist_min_pixel >= HUGEVAL) stop 'Error in detecting pixel for color image'

          ! sets closest GLL point for pixel location
          if (iglob_image_color(i,j) == -1) then
            ! sets new pixel
            iglob = ibool(pixel_k,pixel_l,ispec)
            iglob_image_color(i,j) = iglob
            nb_pixel_loc = nb_pixel_loc + 1
          endif
        endif
      enddo
    enddo
  enddo

  ! user output
  nb_pixel_total = nb_pixel_loc
  write(*,*) '  total number of image pixels = ',nb_pixel_total
  write(*,*)

!
!----  find pixel position of the sources and receivers
!

    ! find pixel position of the sources with orange crosses
    do i = 1,NSOURCES
      ix_image_color_source(i) = int((x_source - xmin_color_image) / size_pixel_horizontal) + 1
      iy_image_color_source(i) = int((z_source - zmin_color_image) / size_pixel_vertical) + 1

      ! avoid edge effects
      if (ix_image_color_source(i) < 1) ix_image_color_source(i) = 1
      if (iy_image_color_source(i) < 1) iy_image_color_source(i) = 1

      if (ix_image_color_source(i) > NX_IMAGE_color) ix_image_color_source(i) = NX_IMAGE_color
      if (iy_image_color_source(i) > NZ_IMAGE_color) iy_image_color_source(i) = NZ_IMAGE_color
    enddo

    ! find pixel position of the receivers with green squares
    do i = 1,nrec
      ix_image_color_receiver(i) = int((x_receiver - xmin_color_image) / size_pixel_horizontal) + 1
      iy_image_color_receiver(i) = int((z_receiver - zmin_color_image) / size_pixel_vertical) + 1

      ! avoid edge effects
      if (ix_image_color_receiver(i) < 1) ix_image_color_receiver(i) = 1
      if (iy_image_color_receiver(i) < 1) iy_image_color_receiver(i) = 1

      if (ix_image_color_receiver(i) > NX_IMAGE_color) ix_image_color_receiver(i) = NX_IMAGE_color
      if (iy_image_color_receiver(i) > NZ_IMAGE_color) iy_image_color_receiver(i) = NZ_IMAGE_color
    enddo

  end subroutine prepare_color_image_pixels

