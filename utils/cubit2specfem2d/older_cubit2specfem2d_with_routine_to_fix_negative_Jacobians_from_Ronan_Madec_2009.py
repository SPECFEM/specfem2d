#!/usr/bin/python

#last modified: Juin 2009

#script to convert format Abaqus generated by Cubit in format Specfem2D

#usage : python Cubit2Specfem2D.py input_file


import sys, os
from scipy import *


def readAbaqus(file):
    if  os.path.exists(file) :
        infile=open(file,'r')
	lines=infile.readlines()
	line=lines[0].split(',')
	label=0
	coords=[]
	elem=[]
	i=0
	#read nodes coordinates
	while line[0].strip()!='*NODE' and i<len(lines)-1:
      	    i+=1
	    line=lines[i].split(',')
	i+=1
	line=lines[i].split(',')
	while line[0].rstrip()!='*ELEMENT' and i<len(lines)-1:
            #coords=[...,[i,x(i),y(i),z(i)],...]
            coords.append([int(line[0]),[float(line[1]),float(line[2]),float(line[3])]])
	    i+=1
	    line=lines[i].split(',')

	#read elements with their label
	while i<len(lines)-1:
            i+=1
	    line=lines[i].split(',')
	    label+=1
	    while line[0].rstrip()!='*ELEMENT' and i<len(lines):
                #elem=[...,[i,label,[node(1),node(2),node(3),node(4)]],...]
                elem.append([int(line[0]),label,[int(line[1]),int(line[2]),int(line[3]),int(line[4])]])
		i+=1
                if i!=len(lines):
                    line=lines[i].split(',')

	infile.close()
	return [coords,elem]

    else:
        print file,': file not found'
        sys.exit(-1)

#write mesh file
def writeMesh(elem,jacob,outfile,ifirst):
    file=open(outfile,'w')
    file.write(str(len(elem))+'\n')
    for i in range(len(elem)):
        if jacob[i]==1:
            file.write(str(elem[i][2][ifirst[i]%4])+' '+str(elem[i][2][(ifirst[i]+1)%4])+
                       ' '+str(elem[i][2][(ifirst[i]+2)%4])+' '+str(elem[i][2][(ifirst[i]+3)%4])+'\n')
        elif jacob[i]==-1:
            file.write(str(elem[i][2][ifirst[i]%4])+' '+str(elem[i][2][(ifirst[i]+3)%4])+
                       ' '+str(elem[i][2][(ifirst[i]+2)%4])+' '+str(elem[i][2][(ifirst[i]+1)%4])+'\n')
        else:
            print 'wrong jacobian direction parameter (must be 1 or -1):', jacob[i]
            sys.exit(-1)
    file.close()

#write coords file
def writeNodes(coords,col,outfile):
    file=open(outfile,'w')
    file.write(str(len(coords))+'\n')
    for i in coords:
        file.write(' ')
        for j in col:
            file.write(' '+str(i[1][j]))
	file.write('\n')
    file.close()
    return

#write file with label of each element
def writeMaterials(elem,outfile):
    file=open(outfile,'w')
    for i in elem:
        file.write(str(i[1])+'\n')
    file.close()
    return

#write file after finding free surface boundary edges
def writeFree(coords,elem,abs,outfile):
    x=[]
    z=[]
    for i in coords:
        x.append(i[1][0])
        z.append(i[1][2])

    xmin=min(x[:])
    xmax=max(x[:])
    zmin=min(z[:])
    zmax=max(z[:])

#structure:
#     edges=[...,[[node1,node2],ielem,label],...]
#     bound=[...,[node1,node2],...]
    edges=[]
    bound=[]
    for ielem in elem:
        for k in range(4):
            p1=ielem[2][k]
            p2=ielem[2][(k+1)%4]
            edges.append([[min(p1,p2),max(p1,p2)],ielem[0],ielem[1]])

    #an edge on the boundary is only in one element
    #and an edge on the interior is in two elements
    while len(edges)>0:
        k=1
	count=1
	while k<len(edges) and edges[0][0]!=edges[k][0]:
            k+=1
	if k==len(edges):
            #right
            if x[edges[0][0][0]-1]==x[edges[0][0][1]-1] and x[edges[0][0][0]-1]==xmax:
                if abs[1]==0:
                    bound.append(edges[0])
            #bottom
            elif z[edges[0][0][0]-1]==z[edges[0][0][1]-1] and z[edges[0][0][0]-1]==zmin:
                if abs[2]==0:
                    bound.append(edges[0])
            #left
            elif x[edges[0][0][0]-1]==x[edges[0][0][1]-1] and x[edges[0][0][0]-1]==xmin:
                if abs[3]==0:
                    bound.append(edges[0])
            #top
            elif abs[0]==0:
                bound.append(edges[0])
	else:
            count+=1
            del edges[k]
	del edges[0]

    file=open(outfile,'w')
    file.write(str(len(bound))+'\n')
    for i in bound:
        file.write(str(i[1])+' 2 '+str(i[0][0])+' '+str(i[0][1])+'\n')
    file.close()
    return

#write file after finding absorbing boundary edges
def writeAbsorbing(coords,elem,abs,outfile):
    x=[]
    z=[]
    for i in coords:
        x.append(i[1][0])
        z.append(i[1][2])

    xmin=min(x[:])
    xmax=max(x[:])
    zmin=min(z[:])
    zmax=max(z[:])


#structure:
#     edges=[...,[[node1,node2],ielem,label],...]
#     bound=[...,[node1,node2],...]
    edges=[]
    bound=[]
    for ielem in elem:
        for k in range(4):
            p1=ielem[2][k]
            p2=ielem[2][(k+1)%4]
            edges.append([[min(p1,p2),max(p1,p2)],ielem[0],ielem[1]])

    #an edge on the boundary is only in one element
    #and an edge on the interior is in two elements
    while len(edges)>0:
        k=1
	count=1
	while k<len(edges) and edges[0][0]!=edges[k][0]:
            k+=1
	if k==len(edges):
            #right
            if x[edges[0][0][0]-1]==x[edges[0][0][1]-1] and x[edges[0][0][0]-1]==xmax:
                if abs[1]==1:
                    bound.append(edges[0])
            #bottom
            elif z[edges[0][0][0]-1]==z[edges[0][0][1]-1] and z[edges[0][0][0]-1]==zmin:
                if abs[2]==1:
                    bound.append(edges[0])
            #left
            elif x[edges[0][0][0]-1]==x[edges[0][0][1]-1] and x[edges[0][0][0]-1]==xmin:
                if abs[3]==1:
                    bound.append(edges[0])
            #top
            elif abs[0]==1:
                bound.append(edges[0])
        else:
            count+=1
            del edges[k]
	del edges[0]

    file=open(outfile,'w')
    file.write(str(len(bound))+'\n')
    for i in bound:
        file.write(str(i[1])+' 2 '+str(i[0][0])+' '+str(i[0][1])+'\n')
    file.close()
    return

#check if jacobian of elements are
def check_jacobian(coords,elem):
    jacobian=[]
    positif=0
    negatif=0
    xi=[-1.,1.,1.,-1.]
    gamma=[-1.,-1.,1.,1.]
    for i in range(len(elem)):
        sign_jac=[]
        for k in range(len(elem[i][2])):
            xxi=0.
            zxi=0.
            xgamma=0.
            zgamma=0.
            for ia in range(len(elem[i][2])):
                x=coords[elem[i][2][ia]-1][1][0]
                z=coords[elem[i][2][ia]-1][1][2]
                dershape=der_shape_function(xi[k],gamma[k],ia)
                xxi += dershape[0]*x
                zxi += dershape[0]*z
                xgamma += dershape[1]*x
                zgamma += dershape[1]*z

            if xxi*zgamma - xgamma*zxi == 0:
                print 'error jacobian null on element :', i, 'point :', k
                sys.exit(-1)
            elif xxi*zgamma - xgamma*zxi < 0:
                sign_jac.append(-1)
            else:
                sign_jac.append(1)

        if sign_jac[0]==1:
            if sign_jac[1]!=1 or sign_jac[2]!=1 or sign_jac[3]!=1:
                print 'elem ', i, ' with jacobian not all positif'
                sys.exit(-1)
            jacobian.append(1)
            positif+=1
        elif sign_jac[0]==-1:
            if sign_jac[1]!=-1 or sign_jac[2]!=-1 or sign_jac[3]!=-1:
                print 'elem ', i, ' with jacobian not all negatif'
                sys.exit(-1)
            jacobian.append(-1)
            negatif+=1
        else:
            print 'pb with jacobian in elem :', i

    print 'on the mesh, there is '+str(positif)+' positive jacobian elements (unchanged)'
    print '                  and '+str(negatif)+' negative jacobian elements (re-ordered)'

    return jacobian

def der_shape_function(xi,gamma,inode):
    sm=xi-1.
    sp=xi+1.
    tm=gamma-1.
    tp=gamma+1.

    if inode==0:
        dershape=[.25*tm,.25*sm]
    elif inode==1:
        dershape=[-.25*tm,-.25*sp]
    elif inode==2:
        dershape=[.25*tp,.25*sp]
    elif inode==3:
        dershape=[-.25*tp,-.25*sm]
    else:
        print 'unknown inode for shape function (0,1,2 or 3):', inode
    return dershape

#check if jacobian of elements are
def find_first(coords,elem):
    ifirst=[]
    imin=-1
    for i in range(len(elem)):
        min_sum=1.e100
        for k in range(len(elem[i][2])):
            if (min_sum>(coords[elem[i][2][k]-1][1][0]+coords[elem[i][2][k]-1][1][2])):
                imin=k
                min_sum=coords[elem[i][2][k]-1][1][0]+coords[elem[i][2][k]-1][1][2]
        if (imin>3 or imin<0):
            print 'pb in the detection of best first node element'+str(i)+': ifirst =', imin
            sys.exit(-1)
        ifirst.append(imin)
    return ifirst

#
#
#
#
#----------------------------Script beginning
#
#
#
#

if len(sys.argv)<2:
    print 'usage: python Cubit2Specfem2D.py input_file'
    print '    to change absorbing conditions and precise label of the fluid'
    print '    you have to change vector abs and vector label explicitely given'
    print '    in the script (search "Parameters" in script to find it)'
    print ''
    sys.exit(-1)

inputfile=sys.argv[1]
temp=inputfile.split('.')
name_root_file=temp[0]

#Parameters
#we only need X and Z coordinates
col=[0,2]
#model5
#label=[7]
#bathy
label=[9]

#absorbing conditions: if 0 false, if 1 true
abs_top=0
abs_rig=1
abs_bot=1
abs_lef=1

abs=[abs_top,abs_rig,abs_bot,abs_lef]


mesh_meshfem2D_file=name_root_file+'_mesh_file'
nodes_meshfem2D_file=name_root_file+'_nodes_coords_file'
materials_meshfem2D_file=name_root_file+'_materials_file'
free_surface_meshfem2D_file=name_root_file+'_free_surface_file'
absorbing_surface_meshfem2D_file=name_root_file+'_absorbing_surface_file'

[coords,elem]=readAbaqus(inputfile)
#structures:
#
#    coords=[...,[i,[x(i),y(i),z(i)]],...]
#    elem=[...,[i,label,[node(1)+1,node(2)+1,node(3)+1,node(4)+1]],...]

#jacobian :
#       if it is 1, the element nodes will be written in the same order as Cubit
#       if it is -1, the element nodes will be written in the oposite order as Cubit
jacobian_direction=check_jacobian(coords,elem)

#Find good first element (sum of coordinates the smallest)
ifirst=find_first(coords,elem)

print 'creating mesh file...'
writeMesh(elem,jacobian_direction,mesh_meshfem2D_file,ifirst)

print 'creating nodes file...'
writeNodes(coords,col,nodes_meshfem2D_file)

print 'creating materials file...'
writeMaterials(elem,materials_meshfem2D_file)

print 'creating free surface file... (can be long)'
writeFree(coords,elem,abs,free_surface_meshfem2D_file)

print 'creating absorbing condition file... (can be long)'
writeAbsorbing(coords,elem,abs,absorbing_surface_meshfem2D_file)

sys.exit(0)
